# Демо-проект для отработки механизмов многопоточности

На примере нескольких задач планирую отработать разные механизмы многопоточности. А именно: synchronized-блоки, Lock, 
потокобезопасные коллекции. А так же, пулы потоков, цепочки completable future

Ограничусь наивными реализациями, чтобы не перенасыщать код

Запуск будет доступен из соответствующих тестов

## Задача Производитель-потребитель
Планирую реализовать двумя способами: 
 - с низкоуровневыми блокировками. Отдельно, с использованием кондишенов
 - с использованием потокобезопасных коллекций

Реализую на примере паттерна Команда. 

Продюсер будет рандомно генерить команды, и складывать их в коллекцию.
Потребители (их будет много) - в несколько потоков, будут эти команды из коллекции забирать, и исполнять.

При переполнении коллекции, производитель будет засыпать, с условием уменьшения количества команд в коллекции.
При отсутствии команд в коллекции, аналогично засыпать будут потребители.

### Решение на основе потокобезопасных коллекций
Потокобезопасные коллекции внутри себя уже содержат некоторые механизмы обеспечения корректной работы с Общим состоянием в многопоточной среде.
Используя их, нет потребности в применении внешних блокировок. 

Для того чтобы пощупать этот подход, я создал сервис BlockingCollectionCommandTestingService. В его методе invokeWithReport(), стартует два вида процессов - производитель (BlockingCollectionCommandProducer)
и потребители (BlockingCollectionCommandConsumer). Это реализации интерфейса Runnable.

Производитель один, стартует в отдельном потоке. Потребителей - несколько. И они запускаются одновременно в пуле потоков.

Производитель в цикле с фиксированным количеством итераций, создает по 3 Команды за раз, и добавляет их в основную рабочую коллекцию (commands). Из этой же коллекции, потребители и будут постепенно забирать команды для их исполнения.

Команды разнотипные. Для отработки паттерна Команда, заодно. 

В соответствии с идеей паттерна, обьект команды внутри себя хранит всю информацию и алгоритм ее исполнения. А потребитель, только забирает ее из рабочей коллекции, и вызывает ее метод execute().
Т.е., эта коллекция является общим ресурсом, очевидно. На грамотную работу с ней и нацелен этот пример.

Для этого была выбрана реализация ArrayBlockingQueue, с заданной емкостью в 100 элементов. Это обеспечивает 3 ключевых момента:
* Первое - обеспечивается приоритетный доступ к элементам коллекции. Т.е., одновременно пытаясь добавить и удалить элементы, мы не получим КонкаррентМодификейшенЭксэпшн. 
* Второе - При достижении границ наполняемости (коллекция пуста и коллекция полна), не произойдет переполнения. Она сама обеспечивает перевод в Ожидание тех потоков которые пытаются добавить или забрать элементы.
* Третье - при появлении первого элемента после опустошения, коллекция инициирует пробуждение одного из ожидающих потоков. Аналогично при освобождении места. Такой вот notify

Для запуска процесса производства и потребления, существует тест invokeWithReport() в классе BlockingCollectionCommandTestingServiceTest. Он вызывает invokeWithReport() тестового сервиса, и анализирует текстовый отчет.
При пустом отчете - тест пройден. При наличии текста в нем, тест провален. 
В отчет метода попадает, при провале, результат сравнения количества созданных и обработанных команд. Для этого их айдишники постепенно складываются в соответствующие коллекции (тоже потокобезопасные) упакованные в обьект OperationReportObject.
Соответствующие коллекции из этого обьекта регистрируются в производителе и в командах, на стадии их создания. И в конце общего процесса, опрашиваются и сравниваются.
Цель сравнения, убедиться что нет повторных обработок, или потери команд.

ArrayBlockingQueue - блокирующая потокобезопасная коллекция. Т.е., работа в многопоточной среде обеспечивается через блокировки в самой коллекции (если пользоваться методами put() и take()).
Пример на основе неблокирующих коллекций скорее всего тоже рассмотрю.

### Решение на основе Непотокобезопасных коллекций
Как и в примере выше, для того чтобы пощупать этот подход, я создал сервис _LockConditionCommandTestingService_. Структура его та же. За исключением дополнительных обьектов (Блокировка и Условия)

В качестве непотокобезопасной коллекции выбран _ArrayDeque_. Ну, точнее, собственная реализация, с ограничением емкости.

Т.к. коллекция не является потокобезопасной, то требуется внешнее управление доступом. Для этого используется обьект блокировки ReentrantLock. А так же, Условия, привязанные к этому обьекту. 
Условий требуется два:
 * на переход в состояние "не пуст", чтобы сигнализировать потребителям, что пора проснуться и попытаться поработать, т.к. теперь коллекция, которую они опрашивают, перестала быть пустой.
 * на переход в состояние "не полон", сигнализировать производителю, что место освободилось. и можно попытаться добавить

И обьект блокировки, и условия, создаются в клиентском коде (_LockConditionCommandTestingService_), и передаются в обьекты производителя и потребителей, в конструкторе.

В общем, структура кода осталась той же что и в примере с потокобезопасными коллекциями. Но в производителе и потребителях теперь, блок кода с обращением к общему ресурсу обрамляется вызовом метода блокировки
и разблокировки. А так же, операция добавления/удаления Команды, предваряется проверкой на заполненность. И если таки де, то инициируется засыпание, по соответствующему объекту условия.

Запуск примера, аналогично, через тест invokeWithReport() в классе _LockConditionCommandTestingServiceTest_.

## Задача Банковские переводы
Планирую реализовать тремя способами:
- с низкоуровневыми блокировками synchronized
- Lock
- с использованием потокобезопасных коллекций

Рассматривается пример модели банка с набором счетов, между которыми хаотично переводятся деньги.
Требуется реализовать это в многопоточном исполнении. 

Критерий успешности - в наивном варианте, сохранение ожидаемого общего баланса в итоге каждой транзакции

### Наблюдения и выводы
#### По synchronized
В двух исполнениях, с низкоуровневым порождением потоков (_BankMultiThreadTestServiceImpl_), против 
пула потоков (_BankThreadPoolTestServiceImpl_), время обработки потока операций сильно отличается в 
пользу new Thread(). Это если задать постоянную емкость пула около 25 потоков. Разница времени исполнения - троекратная. 2,5сек против 6,5сек.
Объясняется тем что при прямом порождении потоков, их используется больше. И сама jvm/операционка оптимизирует работу.
При установке 3000 потоков, в пуле, результаты практически сравниваются, но пул все-же помедленнее. Обьяснить это не могу. Возможно 
вмешивается оптимизация платформы, или jvm. 3000 потоков то реально не запускаются конечно.

Вообще, надо сказать что обеспечить реальное исполнение эмулятора вычислений оказалось нетривиально. Пришлось потанцевать с бубном, чтобы 
все не оказалось прооптимизировано и выкинуто. Метод hardWorkEmulate обеспечивает задержку в задаче, не давая ее сократить. 

В BankSynchronizedImpl, с методами помеченными как synchronized, каждая операция перевода работает ожидаемо четко.
Но при удалении **synchronized** из сигнатуры getTotal, так же ожидаемо, начинает разваливаться контроль состояния счетов после 
перевода. Ясно что подсчет общего баланса ловит продолжающиеся изменения состояния счетов (когда транзакция
совершена еще не полностью).

Однако, итоговый баланс, после завершения всех переводов, все-равно корректный. Это обеспечивается синхронизацией методов, в AccountSynchronizedImpl.
Невозможно внести изменение в состояние счета, пока атомарно не завершится уже начатая операция из другого потока 

#### По ReentrantLock
Заменил synchronized на использование ReentrantLock. Успешно. Время работы такое-же, плюс-минус. 
Ну это и понятно. Ведь synchronized использует тот же механизм Lock, только на самом объекте. Блокируя все обращения к нему, из другого потока