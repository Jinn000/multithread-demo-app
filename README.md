# Демо-проект для отработки механизмов многопоточности

На примере нескольких задач планирую отработать разные механизмы многопоточности. А именно: synchronized-блоки, Lock, 
потокобезопасные коллекции. А так же, пулы потоков, цепочки completable future

Ограничусь наивными реализациями, чтобы не перенасыщать код

Запуск будет доступен из соответствующих тестов

## Задача Производитель-потребитель
Планирую реализовать двумя способами: 
 - с низкоуровневыми блокировками. Отдельно, с использованием кондишенов
 - с использованием потокобезопасных коллекций


## Задача Банковские переводы
Планирую реализовать тремя способами:
- с низкоуровневыми блокировками synchronized
- Lock
- с использованием потокобезопасных коллекций

Рассматривается пример модели банка с набором счетов, между которыми хаотично переводятся деньги.
Требуется реализовать это в многопоточном исполнении. 

Критерий успешности - в наивном варианте, сохранение ожидаемого общего баланса в итоге каждой транзакции

### Наблюдения и выводы
#### По synchronized
В двух исполнениях, с низкоуровневым порождением потоков (_BankMultiThreadTestServiceImpl_), против 
пула потоков (_BankThreadPoolTestServiceImpl_), время обработки потока операций сильно отличается в 
пользу new Thread(). Это если задать постоянную емкость пула около 25 потоков. Разница времени исполнения - троекратная. 2,5сек против 6,5сек.
Объясняется тем что при прямом порождении потоков, их используется больше. И сама jvm/операционка оптимизирует работу.
При установке 3000 потоков, в пуле, результаты практически сравниваются, но пул все-же помедленнее. Обьяснить это не могу. Возможно 
вмешивается оптимизация платформы, или jvm. 3000 потоков то реально не запускаются конечно.

Вообще, надо сказать что обеспечить реальное исполнение эмулятора вычислений оказалось нетривиально. Пришлось потанцевать с бубном, чтобы 
все не оказалось прооптимизировано и выкинуто. Метод hardWorkEmulate обеспечивает задержку в задаче, не давая ее сократить. 

В BankSynchronizedImpl, с методами помеченными как synchronized, каждая операция перевода работает ожидаемо четко.
Но при удалении **synchronized** из сигнатуры getTotal, так же ожидаемо, начинает разваливаться контроль состояния счетов после 
перевода. Ясно что подсчет общего баланса ловит продолжающиеся изменения состояния счетов (когда транзакция
совершена еще не полностью).

Однако, итоговый баланс, после завершения всех переводов, все-равно корректный. Это обеспечивается синхронизацией методов, в AccountSynchronizedImpl.
Невозможно внести изменение в состояние счета, пока атомарно не завершится уже начатая операция из другого потока 

#### По ReentrantLock
Заменил synchronized на использование ReentrantLock. Успешно. Время работы такое-же, плюс-минус. 
Ну это и понятно. Ведь synchronized использует тот же механизм Lock, только на самом объекте. Блокируя все обращения к нему, из другого потока